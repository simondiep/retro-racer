<canvas id="canvas" width="500" height="500"></canvas>
<script>
  const canvas = document.getElementById("canvas");
  const context = canvas.getContext("2d");

  let trackLength;
  const LANES = 3;
  const rumbleLength = 3;
  const segmentLength = 200;
  let segments = [];
  const TOTAL_SEGMENTS = 500;
  let speed = 0;
  let playerX = 0;
  const FPS = 30;
  const SHAKE_INTENSITY = 2;

  const maxSpeed = segmentLength * FPS / 20;
  const accel = maxSpeed/5;
  const breaking = -maxSpeed;
  const decel = -maxSpeed/5;
  const offRoadDecel = -maxSpeed/2;
  const offRoadLimit =  maxSpeed/4;

  const keyPressed = {
    UP: false,
    DOWN: false,
    LEFT: false,
    RIGHT: false,
  }

  function initializeRoadSegments() {
    segments = [];
    for(var n = 0 ; n < TOTAL_SEGMENTS ; n++) {
      segments.push({
         index: n,
         z1: n * segmentLength,
         z2: (n+1) * segmentLength,
         showLaneStripe: Math.floor(n/rumbleLength)%2 ? true : false,
         rumbleColor: Math.floor(n/rumbleLength)%2 ? 'red' : 'white',
      });
    }
    trackLength = segments.length * segmentLength;
  }

  function convertRoadTo2d(playerX, z, currentZPosition, isLooped, trackLength) {
    const cameraY = canvas.height - 50;
    const cameraZ = isLooped ? currentZPosition - trackLength : currentZPosition;
    const fieldOfView = 100;
    const cameraDepth = 1 / Math.tan((fieldOfView/2) * Math.PI/180);
    const roadWidth = 1000;
    const translatedX = -playerX * roadWidth;
    const translatedY = -cameraY;
    const translatedZ = Math.abs(z - cameraZ);
    const scale = cameraDepth/translatedZ;
    return {
      x: Math.round((canvas.width/2)  + (scale * translatedX  * canvas.width/2)),
      y: Math.round((canvas.height/2) - (scale * translatedY  * canvas.height/2)),
      w: Math.round((scale * roadWidth   * canvas.width/2)),
    };
  };

  initializeRoadSegments();
  let currentZPosition = 0;
  let baseSegment = segments[currentZPosition];
  const drawDistance = 300;

  function renderLoop() {
    // Sky
    context.fillStyle = 'lightblue';
    context.fillRect(0,0,canvas.width, canvas.height);
    // TODO render scenery/background

    const dx = (1/FPS) * 2 * (speed/maxSpeed); // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
    if (keyPressed.LEFT) {
      playerX = playerX - dx;
    }
    else if (keyPressed.RIGHT)
      playerX = playerX + dx;

    if (playerX > 2) {
      playerX = 2;
    } else if (playerX < -2) {
      playerX = -2;
    }

    if (keyPressed.UP)
      speed = speed + (accel / FPS);
    else if (keyPressed.DOWN)
      speed = speed + (breaking / FPS);
    else
      speed = speed + (decel / FPS);

    // offroad
    if (((playerX < -1) || (playerX > 1)) && (speed > offRoadLimit)) {
      speed = speed + (offRoadDecel / FPS);
    }

    if (speed < 0) {
      speed = 0;
    } else if (speed > maxSpeed) {
      speed = maxSpeed;
    }

    currentZPosition += speed;
    if (currentZPosition > trackLength) {
      currentZPosition -= trackLength;
    }

    for(n = 0 ; n < drawDistance ; n++) {
      segment = segments[(baseSegment.index + n) % segments.length];
      const isLooped = segment.index < baseSegment.index;
      const segment2D_1 = convertRoadTo2d(playerX, segment.z1, currentZPosition, isLooped, trackLength);
      const segment2D_2 = convertRoadTo2d(playerX, segment.z2, currentZPosition, isLooped, trackLength);

      context.fillStyle = 'green';
      context.fillRect(0, segment2D_2.y, canvas.width, segment2D_1.y - segment2D_2.y);
      const rumbleWidth1 = segment2D_1.w/6;
      const rumbleWidth2 = segment2D_2.w/6;
      
      // left rumble
      drawShape({
        x1: segment2D_1.x - segment2D_1.w - rumbleWidth1,
        y1: segment2D_1.y,
        x2: segment2D_1.x - segment2D_1.w,
        y2: segment2D_1.y,
        x3: segment2D_2.x - segment2D_2.w,
        y3: segment2D_2.y,
        x4: segment2D_2.x - segment2D_2.w - rumbleWidth2,
        y4: segment2D_2.y,
        color: segment.rumbleColor,
      });
      // right rumble
      drawShape({
        x1: segment2D_1.x + segment2D_1.w + rumbleWidth1,
        y1: segment2D_1.y,
        x2: segment2D_1.x + segment2D_1.w,
        y2: segment2D_1.y,
        x3: segment2D_2.x + segment2D_2.w,
        y3: segment2D_2.y,
        x4: segment2D_2.x + segment2D_2.w + rumbleWidth2,
        y4: segment2D_2.y,
        color: segment.rumbleColor,
      });
      // road
      drawShape({
        x1: segment2D_1.x - segment2D_1.w,
        y1: segment2D_1.y,
        x2: segment2D_1.x + segment2D_1.w,
        y2: segment2D_1.y,
        x3: segment2D_2.x + segment2D_2.w,
        y3: segment2D_2.y,
        x4: segment2D_2.x - segment2D_2.w,
        y4: segment2D_2.y,
        color: 'gray',
      });

      if (segment.showLaneStripe) {
        const laneMarkerWidth1 = segment2D_1.w/64;
        const laneMarkerWidth2 = segment2D_2.w/64;
        const laneWidth1 = segment2D_1.w * 2/LANES;
        const laneWidth2 = segment2D_2.w * 2/LANES;
        let laneX1 = segment2D_1.x - segment2D_1.w + laneWidth1;
        let laneX2 = segment2D_2.x - segment2D_2.w + laneWidth2;
        for(let lane = 1 ; lane < LANES ; lane++) {
          // Lane stripe
          drawShape({
            x1: laneX1 - laneMarkerWidth1/2,
            y1: segment2D_1.y,
            x2: laneX1 + laneMarkerWidth1/2,
            y2: segment2D_1.y,
            x3: laneX2 + laneMarkerWidth2/2,
            y3: segment2D_2.y,
            x4: laneX2 - laneMarkerWidth2/2,
            y4: segment2D_2.y,
            color: 'white',
          });
          laneX1 += laneWidth1;
          laneX2 += laneWidth2;
        }
      }

      baseSegment = segments[Math.floor(currentZPosition/segmentLength) % segments.length];
      // TODO render fog
    }

    // shake car more when going faster
    const shakeCarX = (speed / maxSpeed) * getRandomArbitrary(-SHAKE_INTENSITY,SHAKE_INTENSITY);
    const shakeCarY = (speed / maxSpeed) * getRandomArbitrary(-SHAKE_INTENSITY,SHAKE_INTENSITY);

    // Draw Car
    context.drawImage(
      document.getElementById('carImage'),
      canvas.width / 2 - 100,
      canvas.height - 250,
      200 + shakeCarX,
      200 + shakeCarY,
    );

    context.fillStyle = "white";
    context.font = "30px Arial";
    context.fillText("Speed: " + speed, 20, 100);
    context.fillText("Distance: " + currentZPosition, 20, 40);
  }

  setInterval(() => {
    requestAnimationFrame(renderLoop);
  }, 1000 / FPS);

  function drawShape(shape) {
    const {x1, y1, x2, y2, x3, y3, x4, y4, color} = shape;
    context.fillStyle = color;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(x3, y3);
    context.lineTo(x4, y4);
    context.closePath();
    context.fill();
  }

  function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
  }

  document.addEventListener('keydown', keyDownHandler);

  function keyDownHandler(event) {
    switch (event.keyCode) {
      case 65: //Left(a)
        keyPressed.LEFT = true;
        break;
      case 68: //Right(d)
        keyPressed.RIGHT = true;
        break;
      case 83: //Down(s)
        keyPressed.DOWN = true;
        break;
      case 87: //Up(w)
        keyPressed.UP = true;
        break;
    }
  }

  document.addEventListener('keyup', keyUpHandler);

  function keyUpHandler(event) {
    switch (event.keyCode) {
      case 65: //Left(a)
        keyPressed.LEFT = false;
        break;
      case 68: //Right(d)
        keyPressed.RIGHT = false;
        break;
      case 83: //Down(s)
        keyPressed.DOWN = false;
        break;
      case 87: //Up(w)
        keyPressed.UP = false;
        break;
    }
  }

</script>
<h1>Retro Racer</h1>
<div>WASD Controls</div>
<div>Hold W to accelerate</div>
<img id="carImage" src="car.png" style="display:none"/>